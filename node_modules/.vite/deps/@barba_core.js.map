{
  "version": 3,
  "sources": ["../../@barba/core/src/modules/Logger.ts", "../../@barba/core/src/defs/hooks.ts", "../../node_modules/path-to-regexp/dist.es2015/index.js", "../../@barba/core/src/schemas/attribute.ts", "../../@barba/core/src/utils/dom.ts", "../../@barba/core/src/utils/history.ts", "../../@barba/core/src/utils/helpers.ts", "../../@barba/core/src/utils/url.ts", "../../@barba/core/src/utils/request.ts", "../../node_modules/is-promise/index.mjs", "../../@barba/core/src/utils/run-async.ts", "../../@barba/core/src/hooks.ts", "../../@barba/core/src/modules/Ignore.ts", "../../@barba/core/src/modules/Cache.ts", "../../@barba/core/src/modules/Headers.ts", "../../@barba/core/src/modules/Prevent.ts", "../../@barba/core/src/modules/Error.ts", "../../@barba/core/src/modules/Store.ts", "../../@barba/core/src/modules/Transitions.ts", "../../@barba/core/src/modules/Views.ts", "../../@barba/core/src/polyfills/index.ts", "../../@barba/core/src/schemas/page.ts", "../../@barba/core/src/core.ts"],
  "sourcesContent": ["/**\n * @barba/core/modules/Logger\n * <br><br>\n * ## Logger.\n *\n * - Display informations via the console\n *\n * @module core/modules/Logger\n * @preferred\n */\n\n/***/\n\n/**\n * Log levels, all lower level messages are printed\n *\n * 0. mute\n * 1. error = `console.error()`\n * 2. warning= `console.warn()`\n * 3. info = `console.info()`\n * 4. debug = `console.log()`\n */\nexport enum LogLevels {\n  off = 0,\n  error = 1,\n  warning = 2,\n  info = 3,\n  debug = 4,\n}\n\n/**\n * Global log level\n */\nlet _level: number = LogLevels.off;\n\nexport class Logger {\n  /**\n   * Get global log level.\n   */\n  public static getLevel(): number {\n    return _level;\n  }\n\n  /**\n   * Set global log level.\n   */\n  public static setLevel(name: keyof typeof LogLevels): number {\n    _level = LogLevels[name];\n\n    return _level;\n  }\n\n  /**\n   * Log \"prefix\".\n   */\n  private _source: string;\n\n  /**\n   * Creates an instance of Logger.\n   */\n  constructor(source: string) {\n    this._source = source;\n  }\n\n  /**\n   * Permanent, unremovable log.\n   */\n  // public print(...objects: any[]): void {\n  //   this._log(console.info, LogLevels.off, objects);\n  // }\n\n  /**\n   * Error log.\n   */\n  public error(...objects: any[]): void {\n    this._log(console.error, LogLevels.error, objects);\n  }\n\n  /**\n   * Warn log.\n   */\n  public warn(...objects: any[]): void {\n    this._log(console.warn, LogLevels.warning, objects);\n  }\n\n  /**\n   * Info log.\n   */\n  public info(...objects: any[]): void {\n    this._log(console.info, LogLevels.info, objects);\n  }\n\n  /**\n   * Debug log.\n   */\n  public debug(...objects: any[]): void {\n    this._log(console.log, LogLevels.debug, objects);\n  }\n\n  /**\n   * Internal logger.\n   */\n  private _log(fn: () => void, level: number, objects: any[]): void {\n    if (level <= Logger.getLevel()) {\n      fn.apply(console, ([`[${this._source}] `].concat(objects) as unknown) as [\n\n      ]);\n    }\n  }\n}\n", "/**\n * @module typings/core\n */\nimport { ITransitionData, ITransitionPage, IViewData } from './index';\n\nexport type HooksBarba =\n  | 'ready'\n  | 'page'\n  | 'reset'\n  | 'currentAdded'\n  | 'currentRemoved'\n  | 'nextAdded'\n  | 'nextRemoved';\n\nexport type HooksOnce = 'beforeOnce' | 'once' | 'afterOnce';\n\nexport type HooksPage =\n  | 'before'\n  | 'beforeLeave'\n  | 'leave'\n  | 'afterLeave'\n  | 'beforeEnter'\n  | 'enter'\n  | 'afterEnter'\n  | 'after';\n\nexport type HooksBefore = 'beforeOnce' | 'beforeLeave' | 'beforeEnter';\nexport type HooksAfter = 'afterOnce' | 'afterLeave' | 'afterEnter';\n\nexport type HooksTransition = HooksOnce | HooksPage;\nexport type HooksView = HooksBefore | HooksAfter;\nexport type HooksAll = HooksBarba | HooksTransition;\n\n// Allow optional \"dynamically created\" hooks\nexport type HooksTransitionMap = { [key in HooksTransition]?: any };\n\nexport type HookFunction = (\n  data?: ITransitionData | IViewData,\n  t?: ITransitionPage\n) => Promise<void> | void;\n\nexport class HookMethods {\n  public before: (fn: HookFunction, ctx?: any) => void;\n  public beforeLeave: (fn: HookFunction, ctx?: any) => void;\n  public leave: (fn: HookFunction, ctx?: any) => void;\n  public afterLeave: (fn: HookFunction, ctx?: any) => void;\n  public beforeEnter: (fn: HookFunction, ctx?: any) => void;\n  public enter: (fn: HookFunction, ctx?: any) => void;\n  public afterEnter: (fn: HookFunction, ctx?: any) => void;\n  public after: (fn: HookFunction, ctx?: any) => void;\n}\n", "/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map", "/**\n * @barba/core/schemas\n * <br><br>\n * ## Schemas description.\n *\n * @module core/schemas\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute } from '../defs';\n\n/**\n * See [[ISchemaAttribute]]\n */\nexport const schemaAttribute: ISchemaAttribute = {\n  container: 'container',\n  history: 'history',\n  namespace: 'namespace',\n  prefix: 'data-barba',\n  prevent: 'prevent',\n  wrapper: 'wrapper',\n};\n", "/**\n * @barba/core/utils/dom\n * <br><br>\n * ## Dom utils\n *\n * - Access DOM contents\n * - DOM vs string conversions\n *\n * @module core/utils/dom\n * @preferred\n */\n\n/***/\n\nimport path from 'path';\n\n// Definitions\nimport { IDomSibling, ISchemaAttribute, Link, Scope, Wrapper } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\nexport class Dom {\n  private _attr: ISchemaAttribute = schemaAttribute;\n  private _parser: DOMParser;\n  private _sibling: IDomSibling = {\n    after: null,\n    before: null,\n    parent: null\n  };\n\n  /**\n   * Convert HTMLDocument to string.\n   */\n  public toString(el: HTMLElement): string {\n    return el.outerHTML;\n  }\n\n  /**\n   * Parse HTML string to HTMLDocument.\n   */\n  // see https://github.com/barbajs/barba/issues/362\n  // Seems that using DOMParser.parseFromString causes this issue.\n  public toDocument(htmlString: string): HTMLDocument {\n    /* istanbul ignore else */\n    if (!this._parser) {\n      this._parser = new DOMParser();\n    }\n    return this._parser.parseFromString(htmlString, 'text/html');\n  }\n\n  /**\n   * Parse HTML string to DIVElement.\n   *\n   * DOMParser.parseFromString fails with img[srcset] on iOS.\n   * see https://github.com/barbajs/barba/issues/362\n   */\n  public toElement(htmlString: string): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.innerHTML = htmlString;\n    return div;\n  }\n\n  /**\n   * Get HTML content.\n   */\n  public getHtml(doc: HTMLDocument = document): string {\n    return this.toString(doc.documentElement);\n  }\n\n  /**\n   * Get full document content.\n   */\n  // getDocument(el = document.documentElement) {\n  //   return this.toStr(el);\n  // },\n\n  /**\n   * Get `[data-barba=\"wrapper\"]`.\n   */\n  public getWrapper(scope: Scope = document): Wrapper {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.wrapper}\"]`\n    );\n  }\n\n  /**\n   * Get `[data-barba=\"container\"]`.\n   */\n  public getContainer(scope: Scope = document): HTMLElement | null {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.container}\"]`\n    );\n  }\n\n  /**\n   * Remove container and store next sibling (if applicable).\n   */\n  public removeContainer(container: HTMLElement) {\n    if (document.body.contains(container)) {\n      this._updateSibling(container);\n      container.parentNode.removeChild(container);\n    }\n  }\n\n  /**\n   * Add container near previous container\n   */\n  public addContainer(container: HTMLElement, wrapper: HTMLElement) {\n    const siblingBefore = this.getContainer() || this._sibling.before;\n\n    if (siblingBefore) {\n      this._insertAfter(container, siblingBefore);\n    } else if (this._sibling.after) {\n      this._sibling.after.parentNode.insertBefore(container, this._sibling.after);\n    } else if (this._sibling.parent) {\n      this._sibling.parent.appendChild(container);\n    } else {\n      wrapper.appendChild(container);\n    }\n  }\n\n  /**\n   * Get current dom sibling\n   */\n  public getSibling(): IDomSibling {\n    return this._sibling;\n  }\n\n  /**\n   * Get `[data-barba-namespace]`.\n   */\n  public getNamespace(scope: Scope = document): string | null {\n    const ns = scope.querySelector(\n      `[${this._attr.prefix}-${this._attr.namespace}]`\n    );\n\n    return ns\n      ? ns.getAttribute(`${this._attr.prefix}-${this._attr.namespace}`)\n      : null;\n  }\n\n  /**\n   * Get URL from `href` value.\n   */\n  public getHref(el: Link): string | null {\n    // HTML tagName is UPPERCASE, xhtml tagName keeps existing case.\n    if (el.tagName && el.tagName.toLowerCase() === 'a') {\n      // HTMLAnchorElement, full URL available\n      if (typeof el.href === 'string') {\n        return el.href;\n      }\n\n      // Probably a SVGAElement…\n      const href = el.getAttribute('href') || el.getAttribute('xlink:href');\n\n      /* istanbul ignore else */\n      if (href) {\n        // When link comes from SVG, `href` returns an object, not a string.\n        const attr: string =\n          ((href as unknown) as SVGAnimatedString).baseVal || href;\n\n        return this.resolveUrl(attr);\n      }\n    }\n    return null;\n  }\n\n  // Copyright 2014 Simon Lydell\n  // X11 (“MIT”) Licensed. (See LICENSE\n  // https://github.com/lydell/resolve-url/blob/master/resolve-url.js\n  /* istanbul ignore next */\n  public resolveUrl(...urls: string[]) {\n    const numUrls = urls.length;\n\n    if (numUrls === 0) {\n      throw new Error('resolveUrl requires at least one argument; got none.');\n    }\n\n    const base = document.createElement('base');\n    base.href = arguments[0];\n\n    if (numUrls === 1) {\n      return base.href;\n    }\n\n    const head = document.getElementsByTagName('head')[0];\n    head.insertBefore(base, head.firstChild);\n\n    const a = document.createElement('a');\n    let resolved;\n\n    for (let index = 1; index < numUrls; index++) {\n      a.href = arguments[index];\n      resolved = a.href;\n      base.href = resolved;\n    }\n\n    head.removeChild(base);\n\n    return resolved;\n  }\n\n  /**\n   * Insert node after another node.\n   */\n  private _insertAfter(newNode: Node, referenceNode: Node) {\n    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n  }\n\n  /**\n   * Update current dom sibling regarding container\n   */\n  private _updateSibling(container: HTMLElement): IDomSibling {\n    this._sibling = {\n      after: container.nextElementSibling,\n      before: container.previousElementSibling,\n      parent: container.parentElement\n    };\n\n    return this._sibling;\n  }\n}\n\nconst dom = new Dom();\n\nexport { dom };\n", "import { HistoryAction, LinkEvent, Trigger } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\n/**\n * @barba/core/utils/history\n * <br><br>\n * ## History manager.\n *\n * - Keep track of the navigation history\n *\n * @module core/utils/history\n * @preferred\n */\n\n/**\n * State item.\n *\n * @property from\n * @property index\n */\ninterface IHistoryItem {\n  /** origin */\n  from: string;\n  /** index */\n  index: number;\n  /** states */\n  states: IStateItem[];\n}\n\n/***/\ninterface ICoords {\n  x: number;\n  y: number;\n}\n\n/**\n * History item.\n *\n * @property namespace\n * @property scroll\n * @property URL\n */\ninterface IStateItem {\n  /** data */\n  data: object;\n  /** namespace */\n  ns: string | undefined;\n  /** Scroll position */\n  scroll: ICoords;\n  /** URL */\n  url: string;\n}\n\nexport class History {\n  private _session: string;\n  private _states: IStateItem[] = [];\n  private _pointer = -1;\n\n  /**\n   * Init with first state.\n   */\n  public init(url: string, ns: string): void {\n    this._session = 'barba';\n\n    const state: IStateItem = {\n      data: {},\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._pointer = 0;\n    this._states.push(state);\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index: this._pointer,\n      states: [...this._states],\n    };\n\n    window.history && window.history.replaceState(item, '', url);\n  }\n\n  public change(\n    url: string,\n    trigger: Trigger,\n    e?: LinkEvent | PopStateEvent\n  ): Trigger {\n    if (e && (e as PopStateEvent).state) {\n      // If popstate, move to existing state\n      // and get back/forward direction.\n      const { state }: { state: IHistoryItem } = e as PopStateEvent;\n      const { index } = state;\n      const diff = this._pointer - index;\n\n      trigger = this._getDirection(diff);\n\n      // Work with previous states\n      this.replace(state.states);\n      this._pointer = index;\n    } else {\n      // Add new state\n      this.add(url, trigger);\n    }\n\n    return trigger;\n  }\n\n  /**\n   * Add a new state.\n   */\n  public add(url: string, trigger: Trigger, action?: HistoryAction, data?: object): void {\n    // If no state, it will be updated later.\n    const ns = 'tmp';\n    const method = action ?? this._getAction(trigger);\n    const state: IStateItem = {\n      data: data ?? {},\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    switch (method) {\n      case 'push':\n        this._pointer = this.size;\n        this._states.push(state);\n        break;\n      case 'replace':\n        this.set(this._pointer, state);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index: this._pointer,\n      states: [...this._states],\n    };\n\n    switch (method) {\n      case 'push':\n        window.history && window.history.pushState(item, '', url);\n        break;\n      case 'replace':\n        window.history && window.history.replaceState(item, '', url);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n  }\n\n  /**\n   * Store custom user data per state.\n   */\n   public store(data: object, i?: number): void {\n     const index = i || this._pointer;\n     const state = this.get(index);\n\n     // merge data (allow data overwrite)\n     state.data = {\n       ...state.data,\n       ...data\n     };\n\n     // update states\n     this.set(index, state);\n\n     const item: IHistoryItem = {\n       from: this._session,\n       index: this._pointer,\n       states: [...this._states],\n     };\n\n     // update browser history\n     window.history.replaceState(item, '');\n   }\n\n  /**\n   * Update state.\n   */\n  public update(data: any, i?: number): void {\n    const index = i || this._pointer;\n    const existing = this.get(index);\n    const state: IStateItem = {\n      ...existing,\n      ...data,\n    };\n\n    this.set(index, state);\n  }\n\n  /**\n   * Remove last state.\n   */\n  public remove(i?: number): void {\n    if (i) {\n      this._states.splice(i, 1);\n    } else {\n      this._states.pop();\n    }\n\n    this._pointer--;\n  }\n\n  /**\n   * Delete all states.\n   */\n  public clear(): void {\n    this._states = [];\n    this._pointer = -1;\n  }\n\n  /**\n   * Replace all states.\n   */\n  public replace(newStates: IStateItem[]): void {\n    this._states = newStates;\n  }\n\n  /**\n   * Get state by index.\n   */\n  public get(index: number): IStateItem {\n    return this._states[index];\n  }\n\n  /**\n   * Set state by index.\n   */\n  public set(i: number, state: IStateItem) {\n    return (this._states[i] = state);\n  }\n\n  /**\n   * Get the current state.\n   */\n  get current(): IStateItem {\n    return this._states[this._pointer];\n  }\n\n  /**\n   * Get the previous state.\n   */\n  get previous(): IStateItem | null {\n    return this._pointer < 1 ? null : this._states[this._pointer - 1];\n  }\n\n  /**\n   * Get the state size.\n   */\n  get size(): number {\n    return this._states.length;\n  }\n\n  /**\n   * Get the history action: push vs replace\n   */\n  private _getAction(trigger: Trigger): HistoryAction {\n    let action: HistoryAction = 'push';\n\n    // Manage `data-barba-history` attribute\n    // to get the right action (push vs replace).\n    const el = trigger as HTMLAnchorElement;\n    const attr = `${schemaAttribute.prefix}-${schemaAttribute.history}`;\n\n    if (el.hasAttribute && el.hasAttribute(attr)) {\n      action = el.getAttribute(attr) as HistoryAction;\n    }\n\n    return action;\n  }\n\n  /**\n   * Get the direction of popstate change\n   */\n  private _getDirection(diff: number): Trigger {\n    // Check if \"session switch\"\n    if (Math.abs(diff) > 1) {\n      // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\n      return diff > 0 ? 'forward' : 'back';\n    } else {\n      if (diff === 0) {\n        return 'popstate';\n      } else {\n        // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\n        return diff > 0 ? 'back' : 'forward';\n      }\n    }\n  }\n}\n\nconst history = new History();\n\nexport { history };\n", "/**\n * @barba/core/utils/helpers\n * <br><br>\n * ## Helpers\n *\n * - Update next page data\n *\n * @module core/utils/helpers\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport { pathToRegexp as ptr } from 'path-to-regexp';\n// Definitions\nimport { IResponse, ITransitionData } from '../defs';\n// Utils\nimport { dom } from './dom';\nimport { history } from './history';\n\n/**\n * Update `data.next`, the title and the history\n */\nexport const update = async (\n  page: Promise<IResponse | void>,\n  data: ITransitionData\n): Promise<void> => {\n  // If not already updated\n  if (!data.next.html) {\n    const response = await page;\n    const { next } = data;\n\n    if (response) {\n      // see: https://github.com/barbajs/barba/issues/362\n      // const nextDocument = dom.toDocument(html);\n      const nextDocument = dom.toElement(response.html);\n\n      next.namespace = dom.getNamespace(nextDocument);\n      next.container = dom.getContainer(nextDocument);\n      // see https://github.com/barbajs/barba/issues/362\n      // next.html = dom.getHtml(nextDocument);\n      // next.html = nextDocument.innerHTML;\n      next.url = response.url;\n      next.html = response.html;\n\n      // Update history namespace (not available when initially set)\n      history.update({ ns: next.namespace });\n\n      // Update title.\n      const { title } = dom.toDocument(response.html);\n\n      document.title = title;\n    }\n  }\n};\n\n/**\n * Next tick\n */\nexport const nextTick = () =>\n  new Promise(resolve => {\n    window.requestAnimationFrame(resolve);\n    // DEV: same result?\n    // setTimeout(resolve, 0);\n  });\n\n/**\n * Turn a route string such as `/user/:name` into a regular expression.\n *\n * Used for:\n *\n * - routes to ignore\n * - route transition resolution\n *\n * @see https://www.npmjs.com/package/path-to-regexp\n */\nconst pathToRegexp = ptr;\n\nexport { pathToRegexp };\n", "/**\n * @barba/core/utils/url\n * <br><br>\n * ## URL utils.\n *\n * - Collect and structure informations from URLs\n *\n * @module core/utils/url\n */\n\n/***/\n\n// Definitions\nimport { IGenericObject, IUrlBase } from '../defs';\n\n/**\n * Get location href.\n */\nexport const getHref = () => window.location.href;\n\n/**\n * Get absolute href from URL.\n */\nexport const getAbsoluteHref = (url: string, base: string = document.baseURI): string => new URL(url, base).href;\n\n/**\n * Get location origin.\n */\nexport const getOrigin = () => window.location.origin;\n\n/**\n * Get port based on URL or location.\n */\nexport const getPort = (url: string = window.location.href) => parse(url).port;\n\n/**\n * Get path from URL.\n */\nexport const getPath = (url: string = window.location.href) => parse(url).path;\n\n/**\n * Get query object from URL.\n */\nexport const getQuery = (url: string, stringify: boolean = false): IGenericObject|string => {\n  return stringify ? JSON.stringify(parse(url).query) : parse(url).query;\n};\n\n/**\n * Get hash from URL.\n */\nexport const getHash = (url: string): string => parse(url).hash;\n\n/**\n * Parse URL for path, query and hash and more.\n */\nexport const parse = (url: string): IUrlBase => {\n  // Port\n  let port;\n  const matches = url.match(/:\\d+/);\n\n  if (matches === null) {\n    if (/^http/.test(url)) {\n      port = 80;\n    }\n\n    if (/^https/.test(url)) {\n      port = 443;\n    }\n  } else {\n    const portString = matches[0].substring(1);\n\n    port = parseInt(portString, 10);\n  }\n\n  // Path\n  let path = url.replace(getOrigin(), '');\n  let hash;\n  let query = {};\n\n  // Hash\n  const hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex + 1);\n    path = path.slice(0, hashIndex);\n  }\n\n  // Query\n  const queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = parseQuery(path.slice(queryIndex + 1));\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    hash,\n    path,\n    port,\n    query,\n  };\n};\n\n/**\n * Parse a query string to object.\n */\nexport const parseQuery = (str: string) =>\n  str.split('&').reduce((acc: IGenericObject, el: string) => {\n    const [key, value] = el.split('=');\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n\n/**\n * Clean URL, remove \"hash\" and/or \"trailing slash\".\n */\nexport const clean = (url: string = window.location.href) =>\n  url.replace(/(\\/#.*|\\/|#.*)$/, '');\n", "/**\n * @barba/core/utils/request\n * <br><br>\n * ## Fetch pages for transitions.\n *\n * - Includes timeout\n * - Uses Fetch API\n * - Handles errors\n *\n * @module core/utils/request\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { Cache } from '@barba/core/src/modules/Cache';\nimport { Headers } from '@barba/core/src/modules/Headers';\nimport { IResponse, RequestError } from '../defs';\nimport { parse } from './url';\n\n/**\n * Init a page request.\n * Fetch the page and returns a promise with the text content.\n */\nfunction request(\n  url: string,\n  ttl: number = 2e3,\n  requestError: RequestError,\n  cache: Cache,\n  headers: Headers\n): Promise<IResponse> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          /* istanbul ignore next: bypass jest since xhr-mock doesn't support custom xhr.responseURL */\n          const responseURL = xhr.responseURL !== '' && xhr.responseURL !== url ? xhr.responseURL : url;\n\n          resolve({\n            html: xhr.responseText,\n            url: {\n              href: responseURL,\n              ...parse(responseURL)\n            },\n          });\n\n          cache.update(url, {\n            status: 'fulfilled',\n            target: responseURL\n          });\n        } else if (xhr.status) {\n          // HTTP code is not 200, reject with response.\n          const response = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n          };\n\n          requestError(url, response);\n          reject(response);\n\n          cache.update(url, { status: 'rejected' });\n        }\n      }\n    };\n\n    xhr.ontimeout = () => {\n      const error = new Error(`Timeout error [${ttl}]`);\n      requestError(url, error);\n      reject(error);\n      cache.update(url, { status: 'rejected' });\n    };\n\n    xhr.onerror = () => {\n      const error = new Error(`Fetch error`);\n      requestError(url, error);\n      reject(error);\n      cache.update(url, { status: 'rejected' });\n    };\n\n    xhr.open('GET', url);\n    xhr.timeout = ttl;\n    xhr.setRequestHeader(\n      'Accept',\n      'text/html,application/xhtml+xml,application/xml'\n    );\n    xhr.setRequestHeader('x-barba', 'yes');\n\n    headers.all().forEach((value, key) => {\n      xhr.setRequestHeader(key, value);\n    });\n\n    xhr.send();\n  });\n}\n\nexport { request };\n", "export default function isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n", "import isPromise from 'is-promise';\n\n// https://github.com/SBoudrias/run-async\n/* istanbul ignore next */\nexport function runAsync(\n  func: (...args: any[]) => void | Promise<any>,\n  ctx: any = {}\n): (...args: any[]) => Promise<any> {\n  return (...args: any[]) => {\n    let async = false;\n\n    const promise = new Promise((resolve, reject) => {\n      // Add async to context\n      ctx.async = () => {\n        async = true;\n\n        return (err: any, value: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        };\n      };\n\n      const answer = func.apply(ctx, args as []);\n\n      if (!async) {\n        if (isPromise(answer)) {\n          (answer as Promise<any>).then(resolve, reject);\n        } else {\n          resolve(answer);\n        }\n      }\n    });\n\n    return promise;\n  };\n}\n", "/**\n * @barba/core/modules/hooks\n * <br><br>\n * ## Hooks manager.\n *\n * - Register and trigger hooks\n *\n * Hooks can be easily registered:\n *\n * ```js\n * hooks.leave(callback, context);\n * ```\n *\n * @module core/modules/hooks\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HookFunction, HookMethods, HooksAll } from './defs';\n// Modules\nimport { Logger } from './modules/Logger';\n// Utils\nimport { runAsync } from './utils';\n// Types\ninterface IHookInfos {\n  ctx: any;\n  fn: HookFunction;\n}\n\nexport class Hooks extends HookMethods {\n  /**\n   * Allow the use of `hooks[name](cb, ctx)`.\n   */\n  [key: string]: any;\n  // [key in HooksAll]?: any;\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All available hooks.\n   *\n   * See [[HooksAll]]\n   */\n  // TODO: get hooks from defs (DRY)?\n  public all: HooksAll[] = [\n    'ready',\n    'page',\n    'reset',\n    'currentAdded',\n    'currentRemoved',\n    'nextAdded',\n    'nextRemoved',\n    'beforeOnce',\n    'once',\n    'afterOnce',\n    'before',\n    'beforeLeave',\n    'leave',\n    'afterLeave',\n    'beforeEnter',\n    'enter',\n    'afterEnter',\n    'after',\n  ];\n  /**\n   * Registered hooks.\n   *\n   * - Unique hook name\n   * - Associated data set(s) (callback + context)\n   */\n  public registered: Map<HooksAll, Set<IHookInfos>> = new Map();\n\n  constructor() {\n    super();\n    this.init();\n  }\n\n  public init() {\n    this.registered.clear();\n    this.all.forEach(hook => {\n      if (!this[hook]) {\n        this[hook] = (fn: HookFunction, ctx?: any) => {\n          if (!this.registered.has(hook)) {\n            this.registered.set(hook, new Set());\n          }\n          const set = this.registered.get(hook);\n\n          set.add({\n            ctx: ctx || {},\n            fn,\n          });\n        };\n      }\n    });\n  }\n\n  /**\n   * Do hook.\n   *\n   * Trigger registered hooks.\n   */\n  public do(name: HooksAll, ...args: any): Promise<any> {\n    if (this.registered.has(name)) {\n      // Let's start a chain of promises\n      let chain = Promise.resolve();\n\n      this.registered.get(name).forEach(hook => {\n        // Chain async hooks promisified\n        chain = chain.then(() => runAsync(hook.fn, hook.ctx)(...args));\n      });\n\n      return chain.catch(error => {\n        this.logger.debug(`Hook error [${name}]`);\n        this.logger.error(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  public clear(): void {\n    this.all.forEach(hook => {\n      delete this[hook];\n    });\n\n    this.init();\n  }\n\n  /**\n   * Help, print available and registered hooks.\n   */\n  public help(): void {\n    this.logger.info(`Available hooks: ${this.all.join(',')}`);\n    const registered: string[] = [];\n    this.registered.forEach((_value: any, key: string) => registered.push(key));\n    this.logger.info(`Registered hooks: ${registered.join(',')}`);\n  }\n}\n\nconst hooks = new Hooks();\n\nexport { hooks };\n", "/**\n * @barba/core/modules/ignore\n * <br><br>\n * ## Manage ignore options.\n *\n * - cache\n * - prefetch\n *\n * @module core/modules/ignore\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption } from '../defs';\n// Utils\nimport { pathToRegexp } from '../utils/helpers';\nimport { parse } from '../utils/url';\n\nexport class Ignore {\n  private _ignoreAll: boolean;\n  private _ignoreRegexes: RegExp[] = [];\n\n  constructor(ignore: IgnoreOption) {\n    if (typeof ignore === 'boolean') {\n      this._ignoreAll = ignore;\n    } else {\n      const paths = Array.isArray(ignore) ? ignore : [ignore];\n\n      this._ignoreRegexes = paths.map(p => pathToRegexp(p));\n    }\n  }\n\n  public checkHref(href: string): boolean {\n    if (typeof this._ignoreAll === 'boolean') {\n      return this._ignoreAll;\n    }\n\n    const { path } = parse(href);\n\n    return this._ignoreRegexes.some(regex => regex.exec(path) !== null);\n  }\n}\n", "/**\n * @barba/core/modules/cache\n * <br><br>\n * ## Cache for storing URL / HTML.\n *\n * @module core/modules/cache\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { CacheAction, CacheRequest, CacheStatus, CacheTarget, ICacheData, IgnoreOption } from '../defs';\n// Modules\nimport { Ignore } from './Ignore';\n\nexport class Cache extends Ignore {\n  private _state: Map<string, ICacheData> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n  }\n\n  /**\n   * Set value to cache\n   */\n  public set(\n    href: string,\n    request: CacheRequest,\n    action: CacheAction,\n    status: CacheStatus,\n    target?: CacheTarget,\n  ): ICacheData {\n    this._state.set(href, {\n      action,\n      request,\n      status,\n      target: target ?? href,\n    });\n\n    return {\n      action,\n      request,\n      status,\n      target,\n    };\n  }\n\n  /**\n   * Get data from cache\n   */\n  public get(href: string): ICacheData {\n    return this._state.get(href);\n  }\n\n  /**\n   * Get request from cache\n   */\n  public getRequest(href: string): CacheRequest {\n    return this._state.get(href).request;\n  }\n\n  /**\n   * Get action from cache\n   */\n  public getAction(href: string): CacheAction {\n    return this._state.get(href).action;\n  }\n\n  /**\n   * Get status from cache\n   */\n  public getStatus(href: string): CacheStatus {\n    return this._state.get(href).status;\n  }\n\n  /**\n   * Get target from cache\n   */\n  public getTarget(href: string): CacheTarget {\n    return this._state.get(href).target;\n  }\n\n  /**\n   * Check if value exists into cache\n   */\n  public has(href: string): boolean {\n    /* istanbul ignore else */\n    if (this.checkHref(href)) {\n      return false;\n    }\n    return this._state.has(href);\n  }\n\n  /**\n   * Delete value from cache\n   */\n  public delete(href: string): boolean {\n    return this._state.delete(href);\n  }\n\n  /**\n   * Update cache value\n   */\n  public update(href: string, data: ICacheData): ICacheData {\n    const state = {\n      ...this._state.get(href),\n      ...data,\n    };\n    this._state.set(href, state);\n\n    return state;\n  }\n}\n", "/**\n * @barba/core/modules/headers\n * <br><br>\n * ## Manage request Headers.\n *\n * @module core/modules/headers\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HeaderList, IHeaderData } from '../defs';\n\nexport class Headers {\n  private _list: HeaderList = new Map();\n\n  /**\n   * Set a new header\n   */\n  public set(name: string, value: string): IHeaderData {\n    this._list.set(name, value);\n\n    return {\n      name: value\n    };\n  }\n\n  /**\n   * Get a specific header\n   */\n  public get(name: string): string {\n    return this._list.get(name);\n  }\n\n  /**\n   * Get all headers\n   */\n  public all(): HeaderList {\n    return this._list;\n  }\n\n  /**\n   * Check if header exists\n   */\n  public has(name: string): boolean {\n    return this._list.has(name);\n  }\n\n  /**\n   * Delete a header\n   */\n  public delete(name: string): boolean {\n    return this._list.delete(name);\n  }\n\n  /**\n   * Clear all headers\n   */\n  public clear(): void {\n    return this._list.clear();\n  }\n}\n", "/**\n * @barba/core/modules/prevent\n * <br><br>\n * ## Prevent checks.\n *\n * - Gathers all the tests that allow Barba to work and play transitions\n *\n * @module core/modules/prevent\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption, Link, PreventCheck } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n// Utils\nimport { url } from '../utils';\n// Modules\nimport { Ignore } from './Ignore';\n\n/**\n * Make sure the browser supports `history.pushState`.\n */\nconst pushState: PreventCheck = () => !window.history.pushState;\n\n/**\n * Make sure there is an `el` and `href`.\n */\nconst exists: PreventCheck = ({ el, href }) => !el || !href;\n\n/**\n * If the user is pressing ctrl + click, the browser will open a new tab.\n */\nconst newTab: PreventCheck = ({ event }) =>\n  (event as KeyboardEvent).which > 1 ||\n  (event as KeyboardEvent).metaKey ||\n  (event as KeyboardEvent).ctrlKey ||\n  (event as KeyboardEvent).shiftKey ||\n  (event as KeyboardEvent).altKey;\n\n/**\n * If the link has `_blank` target.\n */\nconst blank: PreventCheck = ({ el }) =>\n  el.hasAttribute('target') && (el as Link).target === '_blank';\n\n/**\n * If the domain is the same (in order to avoid pushState cross origin security problem).\n * Note: SVGAElement do not have `protocol` neither `hostname` properties.\n */\nconst corsDomain: PreventCheck = ({ el }) =>\n  ((el as HTMLAnchorElement).protocol !== undefined &&\n    window.location.protocol !== (el as HTMLAnchorElement).protocol) ||\n  ((el as HTMLAnchorElement).hostname !== undefined &&\n    window.location.hostname !== (el as HTMLAnchorElement).hostname);\n\n/**\n * If the port is the same.\n * Note: SVGAElement do not have `port` property.\n */\nconst corsPort: PreventCheck = ({ el }) =>\n  (el as HTMLAnchorElement).port !== undefined &&\n  url.getPort() !== url.getPort((el as HTMLAnchorElement).href);\n\n/**\n * If the link has download attribute.\n */\nconst download: PreventCheck = ({ el }) =>\n  el.getAttribute && typeof el.getAttribute('download') === 'string';\n\n/**\n * If the links contains [data-barba-prevent] or [data-barba-prevent=\"self\"].\n */\nconst preventSelf: PreventCheck = ({ el }) =>\n  el.hasAttribute(`${schemaAttribute.prefix}-${schemaAttribute.prevent}`);\n\n/**\n * If some link ancestor contains [data-barba-prevent=\"all\"].\n */\nconst preventAll: PreventCheck = ({ el }) =>\n  Boolean(\n    el.closest(`[${schemaAttribute.prefix}-${schemaAttribute.prevent}=\"all\"]`)\n  );\n\n/**\n * If the link is the current URL.\n *\n * > Not in the test suite.\n */\nconst sameUrl: PreventCheck = ({ href }) =>\n  url.clean(href) === url.clean() && url.getPort(href) === url.getPort();\n\nexport class Prevent extends Ignore {\n  public suite: string[] = [];\n  public tests: Map<string, PreventCheck> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n    this.init();\n  }\n\n  public init(): void {\n    // Add defaults\n    this.add('pushState', pushState);\n    this.add('exists', exists);\n    this.add('newTab', newTab);\n    this.add('blank', blank);\n    this.add('corsDomain', corsDomain);\n    this.add('corsPort', corsPort);\n    this.add('download', download);\n    this.add('preventSelf', preventSelf);\n    this.add('preventAll', preventAll);\n\n    // Outside of the test suite\n    this.add('sameUrl', sameUrl, false);\n  }\n\n  public add(name: string, check: PreventCheck, suite: boolean = true): void {\n    this.tests.set(name, check);\n    suite && this.suite.push(name);\n  }\n\n  /**\n   * Run individual test\n   */\n  public run(name: string, el: Link, event: Event, href: string): boolean {\n    return this.tests.get(name)({\n      el,\n      event,\n      href,\n    });\n  }\n\n  /**\n   * Run test suite\n   */\n  public checkLink(el: Link, event: Event, href: string): boolean {\n    return this.suite.some(name => this.run(name, el, event, href));\n  }\n}\n", "// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class BarbaError extends Error {\n  /* istanbul ignore next */\n  constructor(\n    public error: Error,\n    public label = 'Barba error',\n    ...params: any[]\n  ) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(...params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    /* istanbul ignore else */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BarbaError);\n    }\n\n    this.name = 'BarbaError';\n  }\n}\n", "/**\n * @barba/core/modules/store\n * <br><br>\n * ## Transitions store.\n *\n * - Resolve transition\n * - Manage rules\n *\n * @module core/modules/store\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IRule,\n  IRules,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  RuleName,\n} from '../defs';\n\n// Modules\nimport { Logger } from './Logger';\n\nexport class Store {\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All registered transitions.\n   */\n  public all: ITransitionPage[] = [];\n  /**\n   * \"Page only\" registered transitions.\n   */\n  public page: ITransitionPage[] = [];\n  /**\n   * \"Once only\" registered transitions.\n   */\n  public once: ITransitionOnce[] = [];\n  /**\n   * Rules for transition resolution.\n   *\n   * Defaults:\n   *\n   * - namespace\n   * - custom\n   */\n  private _rules: IRule[] = [\n    {\n      name: 'namespace',\n      type: 'strings',\n    },\n    {\n      name: 'custom',\n      type: 'function',\n    },\n  ];\n\n  /**\n   * Init store.\n   */\n  constructor(transitions: ITransitionPage[] = []) {\n    /* istanbul ignore else */\n    if (transitions) {\n      // TODO: add check for valid transitions? criteria? (once || enter && leave)\n      this.all = this.all.concat(transitions);\n    }\n    this.update();\n  }\n\n  /**\n   * Add rule or transition.\n   */\n  public add(type: 'rule' | 'transition', data: any): void {\n    switch (type) {\n      case 'rule':\n        // TODO: check for valid rule\n        this._rules.splice(data.position || 0, 0, data.value);\n        break;\n      case 'transition':\n      default:\n        // TODO: check for valid transition\n        this.all.push(data);\n        break;\n    }\n\n    this.update();\n  }\n\n  /**\n   * Resolve transition.\n   */\n  public resolve(\n    data: ITransitionData,\n    filters: ITransitionFilters = {}\n  ): ITransitionOnce | ITransitionPage {\n    // Filter on \"once\"\n    let transitions = filters.once ? this.once : this.page;\n\n    // Filter on \"self\"\n    if (filters.self) {\n      transitions = transitions.filter(t => t.name && t.name === 'self');\n    } else {\n      transitions = transitions.filter(t => !t.name || t.name !== 'self');\n    }\n\n    // All matching transition infos\n    const matching = new Map();\n\n    // Active = first of valid transitions\n    // sorted by directions (from/to, from || to, …)\n    const active = transitions.find(t => {\n      let valid = true;\n      const match = {};\n\n      if (filters.self && t.name === 'self') {\n        matching.set(t, match);\n        return true;\n      }\n\n      // Check rules\n      this._rules.reverse().forEach(rule => {\n        if (valid) {\n          valid = this._check(t, rule, data, match);\n          // From/to check\n          if (t.from && t.to) {\n            valid =\n              this._check(t, rule, data, match, 'from') &&\n              this._check(t, rule, data, match, 'to');\n          }\n          if (t.from && !t.to) {\n            valid = this._check(t, rule, data, match, 'from');\n          }\n          if (!t.from && t.to) {\n            valid = this._check(t, rule, data, match, 'to');\n          }\n        }\n      });\n\n      matching.set(t, match);\n\n      return valid;\n    });\n\n    const activeMatch = matching.get(active);\n    const transitionType = [];\n    if (filters.once) {\n      transitionType.push('once');\n    } else {\n      transitionType.push('page');\n    }\n    if (filters.self) {\n      transitionType.push('self');\n    }\n\n    if (activeMatch) {\n      // Log resolved transition\n      const infos: any[] = [active];\n      // Log if matching criteria\n      Object.keys(activeMatch).length > 0 && infos.push(activeMatch);\n\n      this.logger.info(\n        `Transition found [${transitionType.join(',')}]`,\n        ...infos\n      );\n    } else {\n      this.logger.info(`No transition found [${transitionType.join(',')}]`);\n    }\n\n    return active;\n  }\n\n  /**\n   * ### Update store.\n   *\n   * - Reorder transition by priorities\n   * - Get wait indicator\n   * - Get once transitions\n   */\n  public update(): void {\n    // Reorder by priorities\n    this.all = this.all\n      .map(t => this._addPriority(t))\n      .sort((a, b) => a.priority - b.priority)\n      .reverse()\n      .map(t => {\n        delete t.priority;\n\n        return t;\n      });\n    this.page = this.all.filter(\n      t => t.leave !== undefined || t.enter !== undefined\n    ) as ITransitionPage[];\n    this.once = this.all.filter(t => t.once !== undefined) as ITransitionOnce[];\n  }\n\n  /**\n   * ### Check if transition apply.\n   *\n   * Based on rule, page data and optional direction:\n   *\n   * 1. transition has no rule \"property\":\n   *    - always returns true\n   * 2. transition has rule \"property\":\n   *     - \"strings\" should be present on both side (transition + page) and match\n   *     - \"function\" should return true\n   */\n  private _check(\n    transition: ITransitionPage,\n    rule: IRule,\n    data: ITransitionData,\n    match: any,\n    direction?: 'from' | 'to'\n  ): boolean {\n    let isValid = true;\n    let hasMatch = false;\n    const t = transition;\n    const { name, type } = rule;\n    const strRule = name as IRules['strings'];\n    const objRule = name as IRules['object'];\n    const fnName = name as IRules['function'];\n    const base = direction ? t[direction] : t; // = t || t.from || t.to\n    const page = direction === 'to' ? data.next : data.current; // = current || next\n    const exist = direction ? base && base[name] : base[name];\n\n    // If transition rule exists\n    if (exist) {\n      switch (type) {\n        case 'strings':\n        default: {\n          // Array support\n          const names: string[] = Array.isArray(base[strRule])\n            ? (base[strRule] as string[])\n            : [base[strRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[strRule] && names.indexOf(page[strRule]) !== -1) {\n            hasMatch = true;\n          }\n          // If transition prop is different from current, not valid\n          if (names.indexOf(page[strRule]) === -1) {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'object': {\n          // Array support\n          const names: string[] = Array.isArray(base[objRule])\n            ? (base[objRule] as string[])\n            : [base[objRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[objRule]) {\n            if (\n              page[objRule].name &&\n              names.indexOf(page[objRule].name) !== -1\n            ) {\n              hasMatch = true;\n            }\n            // If transition prop is different from current, not valid\n            if (names.indexOf(page[objRule].name) === -1) {\n              isValid = false;\n            }\n          } else {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'function':\n          if (base[fnName](data)) {\n            hasMatch = true;\n          } else {\n            isValid = false;\n          }\n          break;\n      }\n\n      if (hasMatch) {\n        if (direction) {\n          match[direction] = match[direction] || {};\n          match[direction][name] = t[direction][name];\n        } else {\n          match[name] = t[name];\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  /**\n   * ### Calculate transition priority.\n   *\n   * Based on:\n   *\n   * - rule \"position\" (index) give tens, hundreds, thousands, …\n   * - from/to properties give units (0, 1 or 2)\n   */\n  private _calculatePriority(\n    t: ITransitionPage,\n    ruleName: RuleName,\n    ruleIndex: number\n  ): number {\n    let priority = 0;\n\n    if (\n      t[ruleName] ||\n      (t.from && t.from[ruleName]) ||\n      (t.to && t.to[ruleName])\n    ) {\n      priority += Math.pow(10, ruleIndex);\n\n      if (t.from && t.from[ruleName]) {\n        priority += 1;\n      }\n      if (t.to && t.to[ruleName]) {\n        priority += 2;\n      }\n    }\n\n    return priority;\n  }\n\n  private _addPriority(t: ITransitionPage): ITransitionPage {\n    t.priority = 0;\n    let priority = 0;\n\n    this._rules.forEach((rule, i) => {\n      const { name } = rule;\n      const index = i + 1;\n\n      priority += this._calculatePriority(t, name, index);\n    });\n\n    t.priority = priority;\n\n    return t;\n  }\n}\n", "/**\n * @barba/core/modules/transitions\n * <br><br>\n * ## Transitions manager.\n *\n * - Handle hooks and transition lifecycle\n *\n * @module core/modules/transitions\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  HooksTransition,\n  HooksTransitionMap,\n  IResponse,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  Wrapper,\n} from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { dom, helpers, runAsync } from '../utils';\n// Modules\nimport { BarbaError } from './Error';\nimport { Logger } from './Logger';\nimport { Store } from './Store';\n\nexport class Transitions {\n  public logger: Logger = new Logger('@barba/core');\n  public store: Store;\n  private _running: boolean = false;\n\n  constructor(transitions: ITransitionPage[] = []) {\n    this.store = new Store(transitions);\n  }\n\n  /**\n   * Get resolved transition\n   *\n   * - based on data\n   */\n  public get(\n    data: ITransitionData,\n    filters?: ITransitionFilters\n  ): ITransitionOnce | ITransitionPage {\n    return this.store.resolve(data, filters);\n  }\n\n  /**\n   * Animation running status.\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n  set isRunning(status: boolean) {\n    this._running = status;\n  }\n\n  /**\n   * Check for registered once transition(s).\n   */\n  get hasOnce(): boolean {\n    return this.store.once.length > 0;\n  }\n\n  /**\n   * Check for registered self transition.\n   */\n  get hasSelf(): boolean {\n    return this.store.all.some(t => t.name === 'self');\n  }\n\n  /**\n   * ### Wait indicator.\n   *\n   * Tells Barba to get next page data<br>\n   * before starting the resolution<br>\n   * because some registered transitions need<br>\n   * next page data to be resolved (eg: `sync: true`, `to: { namespace }`, …)\n   */\n  get shouldWait(): boolean {\n    return this.store.all.some(t => (t.to && !t.to.route) || t.sync);\n  }\n\n  /**\n   * ### Do \"once\" transition.\n   *\n   * Hooks: see [[HooksOnce]].\n   */\n  public async doOnce({\n    data,\n    transition,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionOnce;\n  }) {\n    const t = transition || {};\n    this._running = true;\n\n    try {\n      await this._doAsyncHook('beforeOnce', data, t);\n      await this.once(data, t);\n      await this._doAsyncHook('afterOnce', data, t);\n    } catch (error) {\n      this._running = false;\n\n      this.logger.debug('Transition error [before/after/once]');\n      this.logger.error(error);\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * ### Do \"page\" transition.\n   *\n   * Hooks: see [[HooksPage]].\n   *\n   * `sync: false` (default) order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. leave\n   * 4. afterLeave\n   * 5. beforeEnter\n   * 6. enter\n   * 7. afterEnter\n   * 8. after\n   *\n   * `sync: true` order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. beforeEnter\n   * 4. leave & enter\n   * 5. afterLeave\n   * 6. afterEnter\n   * 7. after\n   */\n  public async doPage({\n    data,\n    transition,\n    page,\n    wrapper,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionPage;\n    page: Promise<IResponse | void>;\n    wrapper: Wrapper;\n  }) {\n    const t = transition || {};\n    const sync = t.sync === true || false;\n\n    this._running = true;\n\n    try {\n      // Check sync mode, wait for next content\n      if (sync) {\n        await helpers.update(page, data);\n      }\n\n      await this._doAsyncHook('before', data, t);\n\n      if (sync) {\n        try {\n          await this.add(data, wrapper);\n          // Before actions\n          await this._doAsyncHook('beforeLeave', data, t);\n          await this._doAsyncHook('beforeEnter', data, t);\n\n          // Actions\n          await Promise.all([this.leave(data, t), this.enter(data, t)]);\n\n          // After actions\n          await this._doAsyncHook('afterLeave', data, t);\n          await this._doAsyncHook('afterEnter', data, t);\n        } catch (error) {\n          // this.logger.debug('Transition error [sync]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [sync]'\n            );\n          }\n        }\n      } else {\n        let leaveResult: any = false;\n\n        try {\n          // Leave\n          await this._doAsyncHook('beforeLeave', data, t);\n\n          leaveResult = await Promise.all([\n            this.leave(data, t),\n            helpers.update(page, data),\n          ]).then(values => values[0]);\n\n          await this._doAsyncHook('afterLeave', data, t);\n\n          // TODO: check here \"valid\" page result\n          // before going further\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/leave]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [before/after/leave]'\n            );\n          }\n        }\n\n        try {\n          // Enter\n          /* istanbul ignore else */\n          if (leaveResult !== false) {\n            await this.add(data, wrapper);\n\n            await this._doAsyncHook('beforeEnter', data, t);\n            await this.enter(data, t, leaveResult);\n            await this._doAsyncHook('afterEnter', data, t);\n          }\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/enter]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [before/after/enter]'\n            );\n          }\n        }\n      }\n\n      // Remove current container\n      await this.remove(data);\n\n      await this._doAsyncHook('after', data, t);\n    } catch (error: any) {\n      this._running = false;\n\n      // If \"custom/specific\" barba error.\n      /* istanbul ignore else */\n      if (error.name && error.name === 'BarbaError') {\n        this.logger.debug(error.label);\n        this.logger.error(error.error);\n\n        throw error;\n      }\n\n      this.logger.debug('Transition error [page]');\n      this.logger.error(error);\n\n      throw error;\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * Once hook + async \"once\" transition.\n   */\n  public async once(data: ITransitionData, t: ITransitionOnce): Promise<void> {\n    await hooks.do('once', data, t);\n\n    return t.once ? runAsync(t.once, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Leave hook + async \"leave\" transition.\n   */\n  public async leave(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await hooks.do('leave', data, t);\n\n    return t.leave ? runAsync(t.leave, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Enter hook + async \"enter\" transition.\n   */\n  public async enter(\n    data: ITransitionData,\n    t: ITransitionPage,\n    leaveResult?: any\n  ): Promise<void> {\n    await hooks.do('enter', data, t);\n\n    return t.enter\n      ? runAsync(t.enter, t)(data, leaveResult)\n      : Promise.resolve();\n  }\n\n  /**\n   * Add next container.\n   */\n  public async add(data: ITransitionData, wrapper: Wrapper): Promise<void> {\n    dom.addContainer(data.next.container, wrapper);\n    hooks.do('nextAdded', data);\n  }\n\n  /**\n   * Remove current container.\n   */\n  public async remove(data: ITransitionData): Promise<void> {\n    dom.removeContainer(data.current.container);\n    hooks.do('currentRemoved', data);\n  }\n\n  private _isTransitionError(error: any) {\n    if (error.message) {\n      // Errors from request\n      return !/Timeout error|Fetch error/.test(error.message);\n    }\n\n    if (error.status) {\n      // Errors from request\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Do hooks + async transition methods.\n   */\n  private async _doAsyncHook(\n    hook: HooksTransition,\n    data: ITransitionData,\n    t: HooksTransitionMap\n  ): Promise<void> {\n    await hooks.do(hook, data, t);\n\n    return t[hook] ? runAsync(t[hook], t)(data) : Promise.resolve();\n  }\n}\n", "/**\n * @barba/core/modules/views\n * <br><br>\n * ## Views manager.\n *\n * @module core/modules/views\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HooksView, IView, IViewData } from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { runAsync } from '../utils';\n// Types\ntype Hook = (data: IViewData) => Promise<void>;\n\nexport class Views {\n  /**\n   * Available hook names for views.\n   */\n  public names: HooksView[] = [\n    'beforeLeave',\n    'afterLeave',\n    'beforeEnter',\n    'afterEnter',\n  ];\n  /**\n   * Registered views by namespace.\n   */\n  public byNamespace: Map<string, IView> = new Map();\n\n  /**\n   * Init views.\n   */\n  constructor(views: IView[]) {\n    if (views.length === 0) {\n      return;\n    }\n\n    // TODO: add check\n    // for valid views? criteria? (namespace property, string ?)\n    // or duplicate\n    views.forEach(view => {\n      this.byNamespace.set(view.namespace, view);\n    });\n\n    this.names.forEach(name => {\n      hooks[name](this._createHook(name));\n    });\n  }\n\n  /**\n   * Create the hook method.\n   *\n   * - get view based on namespace\n   * - execute callback with transition data\n   */\n  private _createHook(name: HooksView): Hook {\n    return data => {\n      const { namespace } = name.match(/enter/i) ? data.next : data.current;\n      const view = this.byNamespace.get(namespace);\n\n      // TODO: manage self…\n      // if (view && data.trigger !== 'self') {\n      if (view && view[name]) {\n        return runAsync(view[name], view)(data);\n      }\n\n      return Promise.resolve();\n    };\n  }\n}\n", "// Element.prototype.matches polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    (Element as any).prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n}\n\n// Element.prototype.closest polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(s: string) {\n    let el = this;\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = (el.parentElement || el.parentNode) as Element;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n", "/**\n * @module core/schemas\n */\n\n// Definitions\nimport { ISchemaPage } from '../defs';\n\n/**\n * See [[ISchemaPage]]\n */\nexport const schemaPage: ISchemaPage = {\n  container: null,\n  html: '',\n  namespace: '',\n  url: {\n    hash: '',\n    href: '',\n    path: '',\n    port: null,\n    query: {},\n  },\n};\n", "/**\n * @barba/core\n * <br><br>\n * ## Barba core object\n *\n * Main methods:\n *\n * - `.init()` for initialization with options\n * - `.use()` for plugins\n *\n * @module core\n */\n\n/***/\n\nimport { version } from '../package.json';\n// Definitions\nimport {\n  IBarbaOptions,\n  IBarbaPlugin,\n  IgnoreOption,\n  ISchemaPage,\n  ITransitionData,\n  ITransitionOnce,\n  ITransitionPage,\n  Link,\n  LinkEvent,\n  RequestCustomError,\n  RequestErrorOrResponse,\n  SchemaAttributeValues,\n  Trigger,\n  Wrapper,\n} from './defs';\n// Hooks\nimport { hooks } from './hooks';\n// Modules\nimport { Cache } from './modules/Cache';\nimport { Headers } from './modules/Headers';\nimport { Logger } from './modules/Logger';\nimport { Prevent } from './modules/Prevent';\nimport { Transitions } from './modules/Transitions';\nimport { Views } from './modules/Views';\n// Polyfills\nimport './polyfills';\n// Schemas\nimport { schemaAttribute } from './schemas/attribute';\nimport { schemaPage } from './schemas/page';\n// Utils\nimport { dom, helpers, history, request, url } from './utils';\n\nexport class Core {\n  /**\n   * Version.\n   */\n  public version: string = version;\n  /**\n   * Schemas.\n   */\n  public schemaPage: ISchemaPage = schemaPage;\n  /**\n   * Logger class, allows plugins to create Logger.\n   */\n  public Logger: typeof Logger = Logger;\n  /**\n   * Barba logger.\n   */\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * Plugins.\n   */\n  public plugins: IBarbaPlugin<any>[] = [];\n  /**\n   * Options\n   */\n  public timeout: number;\n  public cacheIgnore: IgnoreOption;\n  public cacheFirstPage: boolean;\n  public prefetchIgnore: IgnoreOption;\n  public preventRunning: boolean;\n  /**\n   * Hooks\n   */\n  public hooks = hooks;\n  /**\n   * Modules.\n   */\n  // public history: History;\n  public cache: Cache;\n  public headers: Headers;\n  public prevent: Prevent;\n  public transitions: Transitions;\n  public views: Views;\n  /**\n   * Utils.\n   */\n  public dom = dom;\n  public helpers = helpers;\n  public history = history;\n  public request = request;\n  public url = url;\n\n  private _data: ITransitionData;\n  private _requestCustomError: RequestCustomError;\n  private _wrapper: Wrapper;\n  private _linkEvent: LinkEvent;\n\n  /**\n   * ### Init plugin with options.\n   *\n   * See [[IBarbaPlugin]] for more details.\n   */\n  public use<T>(plugin: IBarbaPlugin<T>, options?: T): void {\n    const installedPlugins = this.plugins;\n\n    // Plugin installation\n    if (installedPlugins.indexOf(plugin) > -1) {\n      this.logger.warn(`Plugin [${plugin.name}] already installed.`);\n\n      return;\n    }\n\n    if (typeof plugin.install !== 'function') {\n      this.logger.warn(`Plugin [${plugin.name}] has no \"install\" method.`);\n\n      return;\n    }\n\n    plugin.install(this, options);\n    installedPlugins.push(plugin);\n  }\n\n  /**\n   * ### Init barba with options.\n   *\n   * See [[IBarbaOptions]] for more details.\n   *\n   * Default values are:\n   *\n   * - transitions: `[]`\n   * - views: `[]`\n   * - schema: [[SchemaAttribute]]\n   * - timeout: `2e3`\n   * - cacheIgnore: `false`\n   * - cacheFirstPage: `false`\n   * - prefetchIgnore: `false`\n   * - preventRunning: `false`\n   * - prevent: `null`,\n   * - debug: `false`\n   * - logLevel: `'debug'`\n   */\n  public init(\n    /** @ignore */ {\n      transitions = [],\n      views = [],\n      schema = schemaAttribute,\n      requestError,\n      timeout = 2e3,\n      cacheIgnore = false,\n      cacheFirstPage = false,\n      prefetchIgnore = false,\n      /* istanbul ignore next */\n      preventRunning = false,\n      prevent: preventCustom = null,\n      debug = false,\n      logLevel = 'off',\n    }: IBarbaOptions = {}\n  ) {\n    // 0. Set logger level and print version\n    Logger.setLevel(debug === true ? 'debug' : logLevel);\n    this.logger.info(this.version);\n\n    // 1. Manage options\n    Object.keys(schema).forEach(k => {\n      const attr = k as SchemaAttributeValues;\n\n      /* istanbul ignore else */\n      if (schemaAttribute[attr]) {\n        schemaAttribute[attr] = schema[attr];\n      }\n    });\n    this._requestCustomError = requestError;\n    this.timeout = timeout;\n    this.cacheIgnore = cacheIgnore;\n    this.cacheFirstPage = cacheFirstPage;\n    this.prefetchIgnore = prefetchIgnore;\n    this.preventRunning = preventRunning;\n\n    // 2. Get and check wrapper\n    this._wrapper = this.dom.getWrapper();\n    if (!this._wrapper) {\n      throw new Error('[@barba/core] No Barba wrapper found');\n    }\n\n    // 3. Init pages (get \"current\" data)\n    this._resetData();\n\n    const { current } = this.data;\n\n    if (!current.container) {\n      throw new Error('[@barba/core] No Barba container found');\n    }\n\n    // 4. Init other modules\n    this.cache = new Cache(cacheIgnore);\n    this.headers = new Headers();\n    this.prevent = new Prevent(prefetchIgnore);\n    this.transitions = new Transitions(transitions);\n    this.views = new Views(views);\n\n    // Add prevent custom\n    if (preventCustom !== null) {\n      if (typeof preventCustom !== 'function') {\n        throw new Error('[@barba/core] Prevent should be a function');\n      }\n\n      this.prevent.add('preventCustom', preventCustom);\n    }\n\n    // 5. Init history\n    this.history.init(current.url.href, current.namespace);\n\n    // 6. Add to cache\n    if (cacheFirstPage) {\n      this.cache.set(current.url.href, Promise.resolve({\n        html: current.html,\n        url: current.url,\n      }), 'init', 'fulfilled');\n    }\n\n    // 7. Bind context\n    this._onLinkEnter = this._onLinkEnter.bind(this);\n    this._onLinkClick = this._onLinkClick.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._bind();\n\n    // 8. Init plugins\n    this.plugins.forEach(plugin => plugin.init());\n\n    // 9. Barba ready\n    // Set next + trigger for once and `beforeEnter`/`afterEnter` view on page load.\n    const onceData = this.data;\n\n    onceData.trigger = 'barba';\n    onceData.next = onceData.current;\n    onceData.current = { ...this.schemaPage };\n    this.hooks.do('ready', onceData);\n\n    // 9. Finally, do once…\n    this.once(onceData);\n\n    // Clean data for first barba transition…\n    this._resetData();\n  }\n\n  public destroy(): void {\n    this._resetData();\n    this._unbind();\n    this.history.clear();\n    this.hooks.clear();\n    this.plugins = [];\n  }\n\n  get data(): ITransitionData {\n    return this._data;\n  }\n\n  get wrapper(): HTMLElement {\n    return this._wrapper;\n  }\n\n  /**\n   * ### Force a page change without Barba transition.\n   */\n  public force(href: string): void {\n    // DEV\n    // Can be used waiting animation cancellation management…\n    window.location.assign(href);\n  }\n\n  /**\n   * ### Go for a Barba transition.\n   *\n   * Manage \"self page\" href:\n   *\n   * - if same url and no self transition, keep default behavior\n   *   - link: reload the page\n   *   - anchor: scroll to\n   * - if same url with self transition, use it\n   * - then start a page transition.\n   */\n  public go(\n    href: string,\n    trigger: Trigger = 'barba',\n    e?: LinkEvent | PopStateEvent\n  ): Promise<void> {\n    this._linkEvent = null;\n\n    // If animation running, force reload\n    if (this.transitions.isRunning) {\n      this.force(href);\n\n      return;\n    }\n\n    let self = false;\n\n    // Check prevent sameURL against current history\n    // + state check\n    // + update trigger with direction\n    if (trigger === 'popstate') {\n      self =\n        this.history.current &&\n        this.url.getPath(this.history.current.url) === this.url.getPath(href) &&\n        this.url.getQuery(this.history.current.url, true) === this.url.getQuery(href, true);\n    } else {\n      self = this.prevent.run('sameUrl', null, null, href);\n    }\n\n    if (self && !this.transitions.hasSelf) {\n      return;\n    }\n\n    trigger = this.history.change(this.cache.has(href) ? this.cache.get(href).target : href, trigger, e);\n\n    if (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    return this.page(href, trigger, e ?? undefined, self);\n  }\n\n  /**\n   * ### Start an \"once\" transition.\n   *\n   * If some registered \"once\" transition,\n   * get the \"resolved\" transition from the store and start it.\n   */\n  public async once(readyData: ITransitionData): Promise<void> {\n    await this.hooks.do('beforeEnter', readyData);\n\n    // Check if once transition\n    if (this.transitions.hasOnce) {\n      const transition = this.transitions.get(readyData, {\n        once: true,\n      }) as ITransitionOnce;\n\n      await this.transitions.doOnce({ transition, data: readyData });\n    }\n\n    await this.hooks.do('afterEnter', readyData);\n  }\n\n  /**\n   * ### Start a \"page\" transition.\n   *\n   * 1. If no running transition, updates data with full URL properties and trigger.\n   * 2. Get page from cache or init request.\n   * 3. Wait if some transitions need \"next\" data (`sync: true`, `to: …`).\n   * 4. Manage the history, depending on trigger.\n   * 5. Get \"data\" and trigger \"go\" hook.\n   * 6. Get the \"resolved\" transition from the store and start it.\n   * 7. Update title and reset data (current, next = undefined).\n   *\n   * > If \"self\", use the \"self\" transition\n   */\n  public async page(\n    href: string,\n    trigger: Trigger,\n    event: LinkEvent | PopStateEvent,\n    self: boolean\n  ): Promise<void> {\n    this.data.next.url = {\n      href,\n      ...this.url.parse(href),\n    };\n    this.data.trigger = trigger;\n    this.data.event = event;\n\n    let page;\n\n    if (this.cache.has(href)) {\n      page = this.cache.update(href, { action: 'click' }).request;\n    } else {\n      const pageRequest = this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, trigger),\n        this.cache,\n        this.headers\n      );\n\n      // manage 301 server response: replace history\n      pageRequest.then(response => {\n        /* istanbul ignore next: bypass jest since xhr-mock doesn't support custom xhr.responseURL */\n        if (response.url.href !== href) {\n          this.history.add(response.url.href, trigger, 'replace');\n        }\n      });\n\n      page = this.cache.set(href, pageRequest, 'click', 'pending').request;\n    }\n\n    // Need to wait before getting the right transition\n    if (this.transitions.shouldWait) {\n      await helpers.update(page, this.data);\n    }\n\n    const data = this.data;\n\n    // Hook: between trigger and transition\n    // Can be used to resolve \"route\"…\n    await this.hooks.do('page', data);\n\n    try {\n      const transition = this.transitions.get(data, {\n        once: false,\n        self,\n      }) as ITransitionPage;\n\n      await this.transitions.doPage({\n        data,\n        page,\n        transition,\n        wrapper: this._wrapper,\n      });\n\n      this._resetData();\n    } catch (error) {\n      // Something went wrong (rejected promise, error, 404, 505, other…)\n      // TODO: manage / use cases for cancellation\n      // this.logger.debug('Transition cancelled');\n\n      // If transition error and no debug mode, force reload page.\n      /* istanbul ignore else */\n      if (Logger.getLevel() === 0) {\n        this.force(data.next.url.href);\n      }\n    }\n  }\n\n  /**\n   * When a request error occurs.\n   *\n   * Allow the user to manage request error. (E.g: 404)\n   */\n  public onRequestError(trigger: Trigger, ...args: any): boolean {\n    // Cancel transition status\n    this.transitions.isRunning = false;\n\n    const [href, response]: [string, RequestErrorOrResponse] = args;\n    const action = this.cache.getAction(href);\n    this.cache.delete(href);\n\n    // Custom requestError returning false will return here.\n    if (\n      this._requestCustomError &&\n      this._requestCustomError(trigger, action, href, response) === false\n    ) {\n      return false;\n    }\n\n    // Force page change\n    if (action === 'click') {\n      this.force(href);\n    }\n    return false;\n  }\n\n  /**\n   * Programmatically prefetch\n   */\n  public prefetch(href: string) {\n\n    // only prefetch absolute href\n    href = this.url.getAbsoluteHref(href);\n\n    // Already in cache\n    /* istanbul ignore next */\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, 'barba'),\n        this.cache,\n        this.headers\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'prefetch',\n      'pending'\n    );\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _bind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.addEventListener('mouseover', this._onLinkEnter);\n      document.addEventListener('touchstart', this._onLinkEnter);\n    }\n    document.addEventListener('click', this._onLinkClick);\n    window.addEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _unbind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.removeEventListener('mouseover', this._onLinkEnter);\n      document.removeEventListener('touchstart', this._onLinkEnter);\n    }\n    document.removeEventListener('click', this._onLinkClick);\n    window.removeEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * When a element is entered.\n   *\n   * Get valid link element.\n   * Cache URL if needed.\n   */\n  private _onLinkEnter(e: LinkEvent): void {\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    const href = this.url.getAbsoluteHref(this.dom.getHref(link));\n\n    if (this.prevent.checkHref(href)) {\n      return;\n    }\n\n    // Already in cache\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, link),\n        this.cache,\n        this.headers\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'enter',\n      'pending'\n    );\n  }\n\n  /**\n   * When an element is clicked.\n   *\n   * Get valid link element.\n   * Prevent same URL.\n   * Go for a Barba transition.\n   */\n  private _onLinkClick(e: LinkEvent): void {\n\n    // This use `prevent.checkLink` under the hood to get eligible link.\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    if (this.transitions.isRunning && this.preventRunning) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      return;\n    }\n\n    this._linkEvent = e;\n\n    this.go(this.dom.getHref(link), link, e);\n  }\n\n  /**\n   * When History state changes.\n   *\n   * Get \"href\" from URL\n   * Go for a Barba transition.\n   */\n  private _onStateChange(e: PopStateEvent): void {\n    this.go(this.url.getHref(), 'popstate', e);\n  }\n\n  /**\n   * Get a valid link ancestor.\n   *\n   * Check for a \"href\" attribute.\n   * Then check if eligible for Barba.\n   */\n  private _getLinkElement(e: LinkEvent): Link {\n    let el = e.target as Link;\n\n    while (el && !this.dom.getHref(el)) {\n      el = (el as HTMLElement).parentNode as Link;\n    }\n\n    // Check prevent\n    if (!el || this.prevent.checkLink(el, e, this.dom.getHref(el))) {\n      return;\n    }\n\n    return el;\n  }\n\n  /**\n   * Reset pages data.\n   *\n   * Set \"current\" and unset \"next\".\n   */\n  private _resetData() {\n    const href = this.url.getHref();\n    const current = {\n      container: this.dom.getContainer(),\n      html: this.dom.getHtml(),\n      namespace: this.dom.getNamespace(),\n      url: {\n        href,\n        ...this.url.parse(href),\n      },\n    };\n\n    this._data = {\n      current,\n      event: undefined,\n      next: { ...this.schemaPage },\n      trigger: undefined,\n    };\n\n    this.hooks.do('reset', this.data);\n  }\n}\n\nconst core = new Core();\n\nexport default core;\n"],
  "mappings": "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",
  "names": ["LogLevels", "before", "beforeLeave", "leave", "this", "afterLeave", "beforeEnter", "enter", "afterEnter", "after", "_level", "off", "Logger", "source", "_source", "t", "getLevel", "setLevel", "name", "_proto", "prototype", "error", "_log", "console", "slice", "call", "arguments", "warn", "warning", "info", "debug", "log", "fn", "level", "objects", "apply", "concat", "escapeString", "str", "replace", "flags", "options", "sensitive", "schemaAttribute", "container", "history", "namespace", "prefix", "prevent", "wrapper", "dom", "_attr", "_parser", "_sibling", "parent", "toString", "el", "outerHTML", "toDocument", "htmlString", "DOMParser", "parseFromString", "toElement", "div", "document", "createElement", "innerHTML", "getHtml", "doc", "documentElement", "getWrapper", "scope", "querySelector", "getContainer", "removeContainer", "body", "contains", "_updateSibling", "parentNode", "removeChild", "n", "addContainer", "siblingBefore", "_insertAfter", "insertBefore", "appendChild", "getSibling", "getNamespace", "ns", "getAttribute", "getHref", "tagName", "toLowerCase", "href", "resolveUrl", "baseVal", "numUrls", "length", "base", "r", "getElementsByTagName", "head", "firstChild", "resolved", "a", "index", "newNode", "referenceNode", "nextSibling", "nextElementSibling", "previousElementSibling", "parentElement", "Dom", "History", "_session", "_states", "_pointer", "init", "url", "state", "data", "scroll", "x", "window", "scrollX", "y", "scrollY", "push", "i", "from", "states", "replaceState", "item", "change", "trigger", "e", "_getDirection", "add", "action", "method", "_getAction", "size", "set", "pushState", "store", "get", "o", "update", "remove", "splice", "pop", "clear", "newStates", "attr", "hasAttribute", "diff", "Math", "abs", "_createClass", "key", "page", "_temp", "next", "html", "then", "response", "nextDocument", "title", "Promise", "resolve", "reject", "pathToRegexp", "path", "keys", "RegExp", "groupsRegex", "execResult", "exec", "suffix", "modifier", "pattern", "Array", "isArray", "paths", "parts", "map", "join", "tokens", "_a", "strict", "_b", "start", "_c", "end", "_d", "encode", "_e", "delimiter", "_f", "endsWith", "endsWithRe", "delimiterRe", "route", "_i", "tokens_1", "token", "mod", "endToken", "isEndDelimited", "indexOf", "char", "type", "value", "count", "j", "TypeError", "code", "charCodeAt", "prefixes", "defaultPattern", "result", "tryConsume", "mustConsume", "consumeText", "name_1", "pattern_1", "requestAnimationFrame", "getOrigin", "location", "origin", "getPort", "parse", "port", "matches", "match", "test", "portString", "substring", "parseInt", "hash", "query", "hashIndex", "queryIndex", "parseQuery", "split", "reduce", "acc", "clean", "baseURI", "stringify", "JSON", "ttl", "requestError", "cache", "headers", "f", "XMLHttpRequest", "xhr", "onreadystatechange", "readyState", "DONE", "status", "responseURL", "responseText", "_extends", "target", "statusText", "ontimeout", "Error", "onerror", "open", "timeout", "setRequestHeader", "all", "forEach", "send", "isPromise", "obj", "runAsync", "func", "ctx", "_arguments", "async", "err", "answer", "promise", "hooks", "_HookMethods", "Hooks", "_this", "logger", "registered", "Map", "_inheritsLoose", "_this2", "hook", "has", "Set", "_this3", "chain", "_this4", "help", "_value", "HookMethods", "Ignore", "ignore", "_ignoreAll", "_ignoreRegexes", "p", "checkHref", "some", "regex", "Cache", "_Ignore", "_state", "request", "getRequest", "getAction", "getStatus", "getTarget", "Headers", "_list", "exists", "newTab", "event", "which", "metaKey", "ctrlKey", "shiftKey", "altKey", "blank", "_ref3", "corsDomain", "protocol", "hostname", "corsPort", "_ref5", "download", "_ref6", "preventSelf", "preventAll", "Boolean", "closest", "sameUrl", "url.clean", "Prevent", "suite", "tests", "check", "run", "checkLink", "BarbaError", "_Error", "label", "captureStackTrace", "_wrapNativeSuper", "Store", "transitions", "once", "_rules", "position", "filters", "filter", "self", "matching", "active", "find", "valid", "reverse", "rule", "_check", "to", "activeMatch", "transitionType", "_this$logger", "infos", "Object", "_addPriority", "sort", "b", "priority", "transition", "direction", "isValid", "hasMatch", "s", "objRule", "fnName", "current", "names", "strRule", "_calculatePriority", "ruleName", "ruleIndex", "pow", "Transitions", "_running", "doOnce", "_ref", "_temp2", "_catch", "_doAsyncHook", "doPage", "_ref2", "_temp11", "_result5", "sync", "c", "_temp9", "_temp7", "_result2", "_isTransitionError", "leaveResult", "_temp3", "_leaveResult", "_temp4", "helpers", "values", "_Promise$all$then", "_temp5", "_temp6", "_temp8", "_temp10", "message", "Views", "views", "byNamespace", "view", "_createHook", "Element", "msMatchesSelector", "webkitMatchesSelector", "nodeType", "schemaPage", "core", "version", "plugins", "cacheIgnore", "cacheFirstPage", "prefetchIgnore", "preventRunning", "_data", "_requestCustomError", "_wrapper", "_linkEvent", "use", "plugin", "installedPlugins", "install", "_ref$transitions", "_ref$views", "_ref$schema", "schema", "_ref$timeout", "_ref$cacheIgnore", "_ref$cacheFirstPage", "_ref$prefetchIgnore", "_ref$preventRunning", "_ref$prevent", "preventCustom", "_ref$debug", "_ref$logLevel", "logLevel", "k", "_resetData", "_onLinkEnter", "bind", "_onLinkClick", "_onStateChange", "_bind", "onceData", "destroy", "_unbind", "force", "assign", "go", "isRunning", "getPath", "getQuery", "hasSelf", "stopPropagation", "preventDefault", "readyData", "hasOnce", "pageRequest", "onRequestError", "shouldWait", "_slice$call", "prefetch", "getAbsoluteHref", "addEventListener", "removeEventListener", "link", "_getLinkElement", "undefined", "Core"]
}
